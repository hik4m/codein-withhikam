[
  {
    "id": "j2download-js-6815",
    "title": "j2download.js",
    "language": "esm",
    "tags": [
      "esm",
      "scrape"
    ],
    "code": "import fetch from \"node-fetch\";\n\nasync function j2download(url) {\n  const ua =\n    \"Mozilla/5.0 (Linux; Android 10; K) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/132.0.0.0 Mobile Safari/537.36\";\n\n  const baseHeaders = {\n    authority: \"j2download.com\",\n    \"accept-language\": \"id-ID,id;q=0.9,en-US;q=0.8,en;q=0.7\",\n    \"sec-ch-ua\": '\"Not A(Brand\";v=\"8\", \"Chromium\";v=\"132\"',\n    \"sec-ch-ua-mobile\": \"?1\",\n    \"sec-ch-ua-platform\": '\"Android\"',\n    \"user-agent\": ua,\n  };\n\n  try {\n    // Ambil cookie + csrf token\n    const home = await fetch(\"https://j2download.com\", {\n      headers: {\n        ...baseHeaders,\n        accept:\n          \"text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8\",\n        \"sec-fetch-dest\": \"document\",\n        \"sec-fetch-mode\": \"navigate\",\n        \"sec-fetch-site\": \"none\",\n        \"upgrade-insecure-requests\": \"1\",\n      },\n    });\n\n    const setCookies = home.headers.raw()[\"set-cookie\"];\n    let cookies = \"\";\n    let csrfToken = \"\";\n\n    if (setCookies) {\n      const cookieArray = [];\n      for (const cookie of setCookies) {\n        const part = cookie.split(\";\")[0];\n        cookieArray.push(part);\n\n        if (part.startsWith(\"csrf_token=\")) {\n          csrfToken = part.split(\"csrf_token=\")[1];\n        }\n      }\n      cookies = cookieArray.join(\"; \");\n    }\n\n    // Request API\n    const result = await fetch(\"https://j2download.com/api/autolink\", {\n      method: \"POST\",\n      headers: {\n        ...baseHeaders,\n        accept: \"application/json, text/plain, */*\",\n        \"content-type\": \"application/json\",\n        cookie: cookies,\n        origin: \"https://j2download.com\",\n        referer: \"https://j2download.com/id\",\n        \"x-csrf-token\": csrfToken,\n      },\n      body: JSON.stringify({\n        data: { url, unlock: true },\n      }),\n    });\n\n    const data = await result.json();\n    return data;\n  } catch (err) {\n    throw new Error(err.message);\n  }\n}\n\nexport default j2download;",
    "category": "scrape",
    "filePath": "Code/scrape/downlaoder/j2download.js.mjs",
    "createdAt": "2026-02-14T11:51:36.815Z"
  },
  {
    "id": "removeclother-js-4566",
    "title": "RemoveClother.js",
    "language": "esm",
    "tags": [
      "esm",
      "scrape"
    ],
    "code": "import axios from 'axios'\nimport fs from 'fs'\nimport path from 'path'\nimport { EventSource } from 'eventsource'\nimport FormData from 'form-data'\nimport https from 'https'\n\nconst BASE_URL = 'https://prithivmlmods-qwen-image-edit-2509-loras-fast.hf.space'\nconst API_PREFIX = '/gradio_api'\nconst TMP_DIR = './tmp/qwenimg'\n\nif (!fs.existsSync(TMP_DIR)) {\n    fs.mkdirSync(TMP_DIR, { recursive: true })\n}\n\nexport class QwenImageEditScraper {\n    constructor() {\n        this.sessionHash = this._genSession()\n        this.axios = axios.create({\n            baseURL: BASE_URL,\n            httpsAgent: new https.Agent({\n                keepAlive: true,\n                rejectUnauthorized: false\n            }),\n            headers: {\n                'User-Agent': 'Mozilla/5.0',\n                Origin: BASE_URL,\n                Referer: `${BASE_URL}/`\n            }\n        })\n    }\n\n    _genSession(len = 11) {\n        const c = 'hy'\n        return Array.from({ length: len }, () => c[Math.floor(Math.random() * c.length)]).join('')\n    }\n\n    _tmpFile(ext = 'jpg') {\n        return path.join(\n            TMP_DIR,\n            `qwen_${Date.now()}_${Math.random().toString(36).slice(2)}.${ext}`\n        )\n    }\n\n    async _bufferToFile(buffer) {\n        const file = this._tmpFile('jpg')\n        fs.writeFileSync(file, buffer)\n        return file\n    }\n\n    async _downloadUrl(url) {\n        const res = await axios.get(url, { responseType: 'arraybuffer' })\n        return this._bufferToFile(res.data)\n    }\n\n    async uploadImage(input) {\n        let filePath\n\n        if (Buffer.isBuffer(input)) {\n            filePath = await this._bufferToFile(input)\n        } else if (typeof input === 'string') {\n            if (input.startsWith('http')) {\n                filePath = await this._downloadUrl(input)\n            } else {\n                filePath = input\n            }\n        } else {\n            throw new Error('INVALID_IMAGE_SOURCE')\n        }\n\n        if (!fs.existsSync(filePath)) {\n            throw new Error('IMAGE_FILE_NOT_FOUND')\n        }\n\n        const form = new FormData()\n        form.append('files', fs.createReadStream(filePath), {\n            filename: path.basename(filePath),\n            contentType: 'image/jpeg'\n        })\n\n        const uploadId = Math.random().toString(36).slice(2, 12)\n        const res = await this.axios.post(\n            `${API_PREFIX}/upload?upload_id=${uploadId}`,\n            form,\n            { headers: form.getHeaders() }\n        )\n\n        await this._waitUpload(uploadId)\n\n        return {\n            path: res.data[0],\n            url: `${BASE_URL}${API_PREFIX}/file=${res.data[0]}`,\n            meta: { _type: 'gradio.FileData' },\n            cleanup: () => {\n                if (filePath && filePath.startsWith(TMP_DIR) && fs.existsSync(filePath)) {\n                    fs.unlinkSync(filePath)\n                }\n            }\n        }\n    }\n\n    async _waitUpload(uploadId) {\n        return new Promise((resolve, reject) => {\n            const es = new EventSource(\n                `${BASE_URL}${API_PREFIX}/upload_progress?upload_id=${uploadId}`\n            )\n\n            es.onmessage = e => {\n                const d = JSON.parse(e.data)\n                if (d.msg === 'done') {\n                    es.close()\n                    resolve()\n                }\n            }\n\n            es.onerror = () => {\n                es.close()\n                resolve()\n            }\n\n            setTimeout(() => reject(new Error('UPLOAD_TIMEOUT')), 30000)\n        })\n    }\n\n   async editImage({ imageSource, prompt }, attempt = 1) {\n    if (!prompt) throw new Error('PROMPT_REQUIRED')\n\n    const file = await this.uploadImage(imageSource)\n    const core = Buffer.from('cnl1aGFu').toString('utf8')\n\n    const payload = {\n        data: [\n            file,\n            String(prompt),\n            'Edit-Skin',\n            0,\n            true,\n            1.0,\n            4,\n            core\n        ],\n        fn_index: 1,\n        trigger_id: 8,\n        session_hash: this.sessionHash\n    }\n\n    try {\n        const res = await this.axios.post(\n            `${API_PREFIX}/queue/join`,\n            payload,\n            { headers: { 'Content-Type': 'application/json' } }\n        )\n\n        return await this._waitResult(res.data.event_id)\n\n    } catch (err) {\n        if (err.message === 'NO_OUTPUT' && attempt < 3) {\n            this.sessionHash = this._genSession()\n            return this.editImage({ imageSource, prompt }, attempt + 1)\n        }\n        throw err\n    } finally {\n        file.cleanup()\n    }\n}\n\n    async _waitResult(eventId) {\n        return new Promise((resolve, reject) => {\n            const es = new EventSource(\n                `${BASE_URL}${API_PREFIX}/queue/data?session_hash=${this.sessionHash}&event_id=${eventId}`\n            )\n\n            es.onmessage = e => {\n                const d = JSON.parse(e.data)\n                if (d.msg === 'process_completed') {\n                    es.close()\n                    const out = d.output?.data?.[0]\nif (!out) {\n    es.close()\n    return reject(new Error('NO_OUTPUT'))\n}\n\n                    resolve({\n                        imageUrl: out.url || `${BASE_URL}${API_PREFIX}/file=${out.path}`,\n                        meta: out\n                    })\n                }\n            }\n\n            es.onerror = () => {\n                es.close()\n                reject(new Error('RESULT_ERROR'))\n            }\n        })\n    }\n}",
    "category": "scrape",
    "filePath": "Code/scrape/tools/RemoveClother.js.mjs",
    "createdAt": "2026-02-14T11:47:04.566Z"
  }
]