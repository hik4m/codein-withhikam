[
  {
    "id": "removebackground-8831",
    "title": "RemoveBackground",
    "language": "javascript",
    "tags": [
      "esm",
      "scrape"
    ],
    "code": "import axios from 'axios'\nimport FormData from 'form-data'\nimport sharp from 'sharp'\n\nlet idToken = null\nlet refreshToken = \"AMf-vBwpudXTnY1FgobhqhDbSVE1ysyhrUQZaxHVNPeViBXZTC8q3f-yawGwDvRNqlokG848eNS8k4SgLCLGp_rb6MUEz0HXoxu-G54TtFismWggMLfimC8nhGUE6PRj0vjplcNhGDN7OPujzDENzuvDDuZLkRBuqyF4kaNYUqAZI_Q_hjYvHJwaWQqJGdKWOGXkv8tNGn_M\"\nlet tokenExpiry = 0\n\nasync function getValidIdToken() {\n    const now = Date.now()\n    \n    if (idToken && (tokenExpiry - now) > 5 * 60 * 1000) {\n        return idToken\n    }\n    \n    try {\n        const response = await axios({\n            method: 'post',\n            url: 'https://securetoken.googleapis.com/v1/token',\n            params: { key: 'AIzaSyAJGrgbFGB_-h8V2oJLr4b-_ipetqM0duU' },\n            headers: {\n                'Content-Type': 'application/json',\n                'X-Android-Package': 'com.photoroom.app',\n                'X-Android-Cert': '0424A4898A4B33940D8BF16E44251B876E97F8D0',\n                'User-Agent': 'Dalvik/2.1.0 (Linux; U; Android 14; sdk_gphone64_x86_64 Build/UE1A.230829.036.A4)'\n            },\n            data: {\n                grant_type: 'refresh_token',\n                refresh_token: refreshToken\n            }\n        })\n\n        idToken = response.data.id_token\n        refreshToken = response.data.refresh_token\n        tokenExpiry = Date.now() + (parseInt(response.data.expires_in) * 1000)\n        \n        return idToken\n        \n    } catch (error) {\n        throw new Error('Gagal mendapatkan token: ' + error.message)\n    }\n}\n\nlet handler = async (m, { conn, usedPrefix, command }) => {\n    let q = m.quoted ? m.quoted : m\n    let mime = (q.msg || q).mimetype || ''\n    if (!/image/.test(mime)) return m.reply(`Kirim/reply gambar dengan caption *${usedPrefix + command}*`)\n\n    m.reply('Sedang memproses...')\n\n    try {\n        const authToken = await getValidIdToken()\n        \n        let img = await q.download()\n        let form = new FormData()\n\n        form.append('sourceImage', img, { filename: 'source.jpg', contentType: 'image/jpeg' })\n        form.append('user_id', '48acFOd8fTfvyjU0nI4oaqKB7512')\n        form.append('resize_mask', 'false')\n        form.append('model_type', 'free')\n        form.append('experiment_flag', 'default')\n\n        const response = await axios({\n            method: 'post',\n            url: 'https://segmentation-inference.photoroom.com/v1/mask',\n            data: form,\n            headers: {\n                ...form.getHeaders(),\n                'User-Agent': 'okhttp/5.3.2',\n                'authorization': authToken,\n                'pr-app-version': '2026.07.02 (2274)',\n                'pr-platform': 'android'\n            }\n        })\n\n        if (response.data && response.data.b64_mask) {\n            let maskBuffer = Buffer.from(response.data.b64_mask, 'base64')\n            const metadata = await sharp(maskBuffer).metadata()\n            \n            const result = await sharp(img)\n                .resize(metadata.width, metadata.height)\n                .joinChannel(maskBuffer)\n                .png()\n                .toBuffer()\n\n            await conn.sendFile(m.chat, result, 'result.png', '✅ Berhasil menghapus background!', m)\n        } else {\n            throw 'Gagal mendapatkan mask dari API.'\n        }\n\n    } catch (error) {\n        if (error.response) {\n            let detail = error.response.data.toString()\n            m.reply(`❌ *API ERROR*:\\n\\`\\`\\`${detail}\\`\\`\\``)\n        } else {\n            m.reply(`❌ *Error:* ${error.message}`)\n        }\n    }\n}\n\nhandler.help = ['removebg']\nhandler.tags = ['tools']\nhandler.command = ['removebg', 'rbg']\n\nexport default handler",
    "category": "scrape",
    "filePath": "Code/scrape/RemoveBackground.js",
    "createdAt": "2026-02-14T14:20:08.831Z"
  },
  {
    "id": "j2download-js-6815",
    "title": "j2download.js",
    "language": "esm",
    "tags": [
      "esm",
      "scrape"
    ],
    "code": "import fetch from \"node-fetch\";\n\nasync function j2download(url) {\n  const ua =\n    \"Mozilla/5.0 (Linux; Android 10; K) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/132.0.0.0 Mobile Safari/537.36\";\n\n  const baseHeaders = {\n    authority: \"j2download.com\",\n    \"accept-language\": \"id-ID,id;q=0.9,en-US;q=0.8,en;q=0.7\",\n    \"sec-ch-ua\": '\"Not A(Brand\";v=\"8\", \"Chromium\";v=\"132\"',\n    \"sec-ch-ua-mobile\": \"?1\",\n    \"sec-ch-ua-platform\": '\"Android\"',\n    \"user-agent\": ua,\n  };\n\n  try {\n    // Ambil cookie + csrf token\n    const home = await fetch(\"https://j2download.com\", {\n      headers: {\n        ...baseHeaders,\n        accept:\n          \"text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8\",\n        \"sec-fetch-dest\": \"document\",\n        \"sec-fetch-mode\": \"navigate\",\n        \"sec-fetch-site\": \"none\",\n        \"upgrade-insecure-requests\": \"1\",\n      },\n    });\n\n    const setCookies = home.headers.raw()[\"set-cookie\"];\n    let cookies = \"\";\n    let csrfToken = \"\";\n\n    if (setCookies) {\n      const cookieArray = [];\n      for (const cookie of setCookies) {\n        const part = cookie.split(\";\")[0];\n        cookieArray.push(part);\n\n        if (part.startsWith(\"csrf_token=\")) {\n          csrfToken = part.split(\"csrf_token=\")[1];\n        }\n      }\n      cookies = cookieArray.join(\"; \");\n    }\n\n    // Request API\n    const result = await fetch(\"https://j2download.com/api/autolink\", {\n      method: \"POST\",\n      headers: {\n        ...baseHeaders,\n        accept: \"application/json, text/plain, */*\",\n        \"content-type\": \"application/json\",\n        cookie: cookies,\n        origin: \"https://j2download.com\",\n        referer: \"https://j2download.com/id\",\n        \"x-csrf-token\": csrfToken,\n      },\n      body: JSON.stringify({\n        data: { url, unlock: true },\n      }),\n    });\n\n    const data = await result.json();\n    return data;\n  } catch (err) {\n    throw new Error(err.message);\n  }\n}\n\nexport default j2download;",
    "category": "scrape",
    "filePath": "Code/scrape/downlaoder/j2download.js.mjs",
    "createdAt": "2026-02-14T11:51:36.815Z"
  },
  {
    "id": "removeclother-js-4566",
    "title": "RemoveClother.js",
    "language": "esm",
    "tags": [
      "esm",
      "scrape"
    ],
    "code": "import axios from 'axios'\nimport fs from 'fs'\nimport path from 'path'\nimport { EventSource } from 'eventsource'\nimport FormData from 'form-data'\nimport https from 'https'\n\nconst BASE_URL = 'https://prithivmlmods-qwen-image-edit-2509-loras-fast.hf.space'\nconst API_PREFIX = '/gradio_api'\nconst TMP_DIR = './tmp/qwenimg'\n\nif (!fs.existsSync(TMP_DIR)) {\n    fs.mkdirSync(TMP_DIR, { recursive: true })\n}\n\nexport class QwenImageEditScraper {\n    constructor() {\n        this.sessionHash = this._genSession()\n        this.axios = axios.create({\n            baseURL: BASE_URL,\n            httpsAgent: new https.Agent({\n                keepAlive: true,\n                rejectUnauthorized: false\n            }),\n            headers: {\n                'User-Agent': 'Mozilla/5.0',\n                Origin: BASE_URL,\n                Referer: `${BASE_URL}/`\n            }\n        })\n    }\n\n    _genSession(len = 11) {\n        const c = 'hy'\n        return Array.from({ length: len }, () => c[Math.floor(Math.random() * c.length)]).join('')\n    }\n\n    _tmpFile(ext = 'jpg') {\n        return path.join(\n            TMP_DIR,\n            `qwen_${Date.now()}_${Math.random().toString(36).slice(2)}.${ext}`\n        )\n    }\n\n    async _bufferToFile(buffer) {\n        const file = this._tmpFile('jpg')\n        fs.writeFileSync(file, buffer)\n        return file\n    }\n\n    async _downloadUrl(url) {\n        const res = await axios.get(url, { responseType: 'arraybuffer' })\n        return this._bufferToFile(res.data)\n    }\n\n    async uploadImage(input) {\n        let filePath\n\n        if (Buffer.isBuffer(input)) {\n            filePath = await this._bufferToFile(input)\n        } else if (typeof input === 'string') {\n            if (input.startsWith('http')) {\n                filePath = await this._downloadUrl(input)\n            } else {\n                filePath = input\n            }\n        } else {\n            throw new Error('INVALID_IMAGE_SOURCE')\n        }\n\n        if (!fs.existsSync(filePath)) {\n            throw new Error('IMAGE_FILE_NOT_FOUND')\n        }\n\n        const form = new FormData()\n        form.append('files', fs.createReadStream(filePath), {\n            filename: path.basename(filePath),\n            contentType: 'image/jpeg'\n        })\n\n        const uploadId = Math.random().toString(36).slice(2, 12)\n        const res = await this.axios.post(\n            `${API_PREFIX}/upload?upload_id=${uploadId}`,\n            form,\n            { headers: form.getHeaders() }\n        )\n\n        await this._waitUpload(uploadId)\n\n        return {\n            path: res.data[0],\n            url: `${BASE_URL}${API_PREFIX}/file=${res.data[0]}`,\n            meta: { _type: 'gradio.FileData' },\n            cleanup: () => {\n                if (filePath && filePath.startsWith(TMP_DIR) && fs.existsSync(filePath)) {\n                    fs.unlinkSync(filePath)\n                }\n            }\n        }\n    }\n\n    async _waitUpload(uploadId) {\n        return new Promise((resolve, reject) => {\n            const es = new EventSource(\n                `${BASE_URL}${API_PREFIX}/upload_progress?upload_id=${uploadId}`\n            )\n\n            es.onmessage = e => {\n                const d = JSON.parse(e.data)\n                if (d.msg === 'done') {\n                    es.close()\n                    resolve()\n                }\n            }\n\n            es.onerror = () => {\n                es.close()\n                resolve()\n            }\n\n            setTimeout(() => reject(new Error('UPLOAD_TIMEOUT')), 30000)\n        })\n    }\n\n   async editImage({ imageSource, prompt }, attempt = 1) {\n    if (!prompt) throw new Error('PROMPT_REQUIRED')\n\n    const file = await this.uploadImage(imageSource)\n    const core = Buffer.from('cnl1aGFu').toString('utf8')\n\n    const payload = {\n        data: [\n            file,\n            String(prompt),\n            'Edit-Skin',\n            0,\n            true,\n            1.0,\n            4,\n            core\n        ],\n        fn_index: 1,\n        trigger_id: 8,\n        session_hash: this.sessionHash\n    }\n\n    try {\n        const res = await this.axios.post(\n            `${API_PREFIX}/queue/join`,\n            payload,\n            { headers: { 'Content-Type': 'application/json' } }\n        )\n\n        return await this._waitResult(res.data.event_id)\n\n    } catch (err) {\n        if (err.message === 'NO_OUTPUT' && attempt < 3) {\n            this.sessionHash = this._genSession()\n            return this.editImage({ imageSource, prompt }, attempt + 1)\n        }\n        throw err\n    } finally {\n        file.cleanup()\n    }\n}\n\n    async _waitResult(eventId) {\n        return new Promise((resolve, reject) => {\n            const es = new EventSource(\n                `${BASE_URL}${API_PREFIX}/queue/data?session_hash=${this.sessionHash}&event_id=${eventId}`\n            )\n\n            es.onmessage = e => {\n                const d = JSON.parse(e.data)\n                if (d.msg === 'process_completed') {\n                    es.close()\n                    const out = d.output?.data?.[0]\nif (!out) {\n    es.close()\n    return reject(new Error('NO_OUTPUT'))\n}\n\n                    resolve({\n                        imageUrl: out.url || `${BASE_URL}${API_PREFIX}/file=${out.path}`,\n                        meta: out\n                    })\n                }\n            }\n\n            es.onerror = () => {\n                es.close()\n                reject(new Error('RESULT_ERROR'))\n            }\n        })\n    }\n}",
    "category": "scrape",
    "filePath": "Code/scrape/tools/RemoveClother.js.mjs",
    "createdAt": "2026-02-14T11:47:04.566Z"
  }
]