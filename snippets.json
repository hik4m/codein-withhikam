[
  {
    "id": "removeclother-js-4566",
    "title": "RemoveClother.js",
    "language": "esm",
    "tags": [
      "esm",
      "scrape"
    ],
    "code": "import axios from 'axios'\nimport fs from 'fs'\nimport path from 'path'\nimport { EventSource } from 'eventsource'\nimport FormData from 'form-data'\nimport https from 'https'\n\nconst BASE_URL = 'https://prithivmlmods-qwen-image-edit-2509-loras-fast.hf.space'\nconst API_PREFIX = '/gradio_api'\nconst TMP_DIR = './tmp/qwenimg'\n\nif (!fs.existsSync(TMP_DIR)) {\n    fs.mkdirSync(TMP_DIR, { recursive: true })\n}\n\nexport class QwenImageEditScraper {\n    constructor() {\n        this.sessionHash = this._genSession()\n        this.axios = axios.create({\n            baseURL: BASE_URL,\n            httpsAgent: new https.Agent({\n                keepAlive: true,\n                rejectUnauthorized: false\n            }),\n            headers: {\n                'User-Agent': 'Mozilla/5.0',\n                Origin: BASE_URL,\n                Referer: `${BASE_URL}/`\n            }\n        })\n    }\n\n    _genSession(len = 11) {\n        const c = 'hy'\n        return Array.from({ length: len }, () => c[Math.floor(Math.random() * c.length)]).join('')\n    }\n\n    _tmpFile(ext = 'jpg') {\n        return path.join(\n            TMP_DIR,\n            `qwen_${Date.now()}_${Math.random().toString(36).slice(2)}.${ext}`\n        )\n    }\n\n    async _bufferToFile(buffer) {\n        const file = this._tmpFile('jpg')\n        fs.writeFileSync(file, buffer)\n        return file\n    }\n\n    async _downloadUrl(url) {\n        const res = await axios.get(url, { responseType: 'arraybuffer' })\n        return this._bufferToFile(res.data)\n    }\n\n    async uploadImage(input) {\n        let filePath\n\n        if (Buffer.isBuffer(input)) {\n            filePath = await this._bufferToFile(input)\n        } else if (typeof input === 'string') {\n            if (input.startsWith('http')) {\n                filePath = await this._downloadUrl(input)\n            } else {\n                filePath = input\n            }\n        } else {\n            throw new Error('INVALID_IMAGE_SOURCE')\n        }\n\n        if (!fs.existsSync(filePath)) {\n            throw new Error('IMAGE_FILE_NOT_FOUND')\n        }\n\n        const form = new FormData()\n        form.append('files', fs.createReadStream(filePath), {\n            filename: path.basename(filePath),\n            contentType: 'image/jpeg'\n        })\n\n        const uploadId = Math.random().toString(36).slice(2, 12)\n        const res = await this.axios.post(\n            `${API_PREFIX}/upload?upload_id=${uploadId}`,\n            form,\n            { headers: form.getHeaders() }\n        )\n\n        await this._waitUpload(uploadId)\n\n        return {\n            path: res.data[0],\n            url: `${BASE_URL}${API_PREFIX}/file=${res.data[0]}`,\n            meta: { _type: 'gradio.FileData' },\n            cleanup: () => {\n                if (filePath && filePath.startsWith(TMP_DIR) && fs.existsSync(filePath)) {\n                    fs.unlinkSync(filePath)\n                }\n            }\n        }\n    }\n\n    async _waitUpload(uploadId) {\n        return new Promise((resolve, reject) => {\n            const es = new EventSource(\n                `${BASE_URL}${API_PREFIX}/upload_progress?upload_id=${uploadId}`\n            )\n\n            es.onmessage = e => {\n                const d = JSON.parse(e.data)\n                if (d.msg === 'done') {\n                    es.close()\n                    resolve()\n                }\n            }\n\n            es.onerror = () => {\n                es.close()\n                resolve()\n            }\n\n            setTimeout(() => reject(new Error('UPLOAD_TIMEOUT')), 30000)\n        })\n    }\n\n   async editImage({ imageSource, prompt }, attempt = 1) {\n    if (!prompt) throw new Error('PROMPT_REQUIRED')\n\n    const file = await this.uploadImage(imageSource)\n    const core = Buffer.from('cnl1aGFu').toString('utf8')\n\n    const payload = {\n        data: [\n            file,\n            String(prompt),\n            'Edit-Skin',\n            0,\n            true,\n            1.0,\n            4,\n            core\n        ],\n        fn_index: 1,\n        trigger_id: 8,\n        session_hash: this.sessionHash\n    }\n\n    try {\n        const res = await this.axios.post(\n            `${API_PREFIX}/queue/join`,\n            payload,\n            { headers: { 'Content-Type': 'application/json' } }\n        )\n\n        return await this._waitResult(res.data.event_id)\n\n    } catch (err) {\n        if (err.message === 'NO_OUTPUT' && attempt < 3) {\n            this.sessionHash = this._genSession()\n            return this.editImage({ imageSource, prompt }, attempt + 1)\n        }\n        throw err\n    } finally {\n        file.cleanup()\n    }\n}\n\n    async _waitResult(eventId) {\n        return new Promise((resolve, reject) => {\n            const es = new EventSource(\n                `${BASE_URL}${API_PREFIX}/queue/data?session_hash=${this.sessionHash}&event_id=${eventId}`\n            )\n\n            es.onmessage = e => {\n                const d = JSON.parse(e.data)\n                if (d.msg === 'process_completed') {\n                    es.close()\n                    const out = d.output?.data?.[0]\nif (!out) {\n    es.close()\n    return reject(new Error('NO_OUTPUT'))\n}\n\n                    resolve({\n                        imageUrl: out.url || `${BASE_URL}${API_PREFIX}/file=${out.path}`,\n                        meta: out\n                    })\n                }\n            }\n\n            es.onerror = () => {\n                es.close()\n                reject(new Error('RESULT_ERROR'))\n            }\n        })\n    }\n}",
    "category": "scrape",
    "filePath": "Code/scrape/tools/RemoveClother.js.mjs",
    "createdAt": "2026-02-14T11:47:04.566Z"
  }
]